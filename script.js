const chessboardElement = document.getElementById('chessboard');const newGameBtn = document.getElementById('newGameBtn');const undoBtn = document.getElementById('undoBtn');const redoBtn = document.getElementById('redoBtn');const difficultySelect = document.getElementById('difficulty');const gameLogElement = document.getElementById('gameLog');const BOARD_SIZE = 8;const PIECE_MAP = {'R': '&#9814;', 'N': '&#9816;', 'B': '&#9815;', 'Q': '&#9813;', 'K': '&#9812;', 'P': '&#9817;', // White'r': '&#9820;', 'n': '&#9822;', 'b': '&#9821;', 'q': '&#9819;', 'k': '&#9818;', 'p': '&#9823;'  // Black};let currentBoard;let currentPlayer; // 'w' for white, 'b' for blacklet moveHistory;let historyIndex;let selectedPiece = null;let aiDelay = 1000; // Default AI delay in ms (Intermediate)function initializeBoard() {currentBoard = [['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],['', '', '', '', '', '', '', ''],['', '', '', '', '', '', '', ''],['', '', '', '', '', '', '', ''],['', '', '', '', '', '', '', ''],['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']];currentPlayer = 'w';moveHistory = [{ board: JSON.parse(JSON.stringify(currentBoard)), turn: currentPlayer, log: [] }];historyIndex = 0;selectedPiece = null;renderBoard();updateControls();updateGameLog('New game started. White to move.');}function renderBoard() {chessboardElement.innerHTML = '';for (let row = 0; row < BOARD_SIZE; row++) {for (let col = 0; col < BOARD_SIZE; col++) {const square = document.createElement('div');square.classList.add('square');square.classList.add((row + col) % 2 === 0 ? 'light' : 'dark');square.dataset.row = row;square.dataset.col = col;const piece = currentBoard[row][col];if (piece) {const pieceElement = document.createElement('div');pieceElement.classList.add('piece');pieceElement.innerHTML = PIECE_MAP[piece];pieceElement.dataset.piece = piece;square.appendChild(pieceElement);}square.addEventListener('click', handleSquareClick);chessboardElement.appendChild(square);}}highlightSelectedPiece();updateGameLogDisplay();}function handleSquareClick(event) {const targetSquare = event.currentTarget;const row = parseInt(targetSquare.dataset.row);const col = parseInt(targetSquare.dataset.col);if (selectedPiece) {const { row: startRow, col: startCol, piece } = selectedPiece;if (startRow === row && startCol === col) { // Deselect if clicking same squaredeselectPiece();} else if (isValidMove(startRow, startCol, row, col)) {makeMove(startRow, startCol, row, col);deselectPiece();} else {deselectPiece(); // Invalid move, deselect}} else { // No piece selected, try to select oneconst pieceElement = targetSquare.querySelector('.piece');if (pieceElement) {const piece = pieceElement.dataset.piece;if ((currentPlayer === 'w' && piece === piece.toUpperCase()) ||(currentPlayer === 'b' && piece === piece.toLowerCase())) {selectPiece(row, col, piece);}}}}function selectPiece(row, col, piece) {deselectPiece();selectedPiece = { row, col, piece };const squareElement = chessboardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);squareElement.classList.add('selected');highlightPossibleMoves(row, col, piece);}function deselectPiece() {if (selectedPiece) {const { row, col } = selectedPiece;const squareElement = chessboardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);squareElement.classList.remove('selected');selectedPiece = null;clearPossibleMoveHighlights();}}function highlightSelectedPiece() {if (selectedPiece) {const { row, col } = selectedPiece;const squareElement = chessboardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);if (squareElement) {squareElement.classList.add('selected');}}}function highlightPossibleMoves(startRow, startCol, piece) {clearPossibleMoveHighlights();for (let row = 0; row < BOARD_SIZE; row++) {for (let col = 0; col < BOARD_SIZE; col++) {if (isValidMove(startRow, startCol, row, col)) {const squareElement = chessboardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);squareElement.classList.add('possible-move');}}}}function clearPossibleMoveHighlights() {document.querySelectorAll('.possible-move').forEach(sq => sq.classList.remove('possible-move'));}function isValidMove(startRow, startCol, endRow, endCol) {// Basic validation: check if target is within board boundsif (endRow < 0 || endRow >= BOARD_SIZE || endCol < 0 || endCol >= BOARD_SIZE) {return false;}const targetPiece = currentBoard[endRow][endCol];const movingPiece = currentBoard[startRow][startCol];const isWhitePiece = movingPiece === movingPiece.toUpperCase();const isTargetEmpty = targetPiece === '';const isTargetOpponent = (isWhitePiece && targetPiece === targetPiece.toLowerCase() && targetPiece !== '') ||(!isWhitePiece && targetPiece === targetPiece.toUpperCase() && targetPiece !== '');// Cannot move to a square occupied by your own pieceif (!isTargetEmpty && !isTargetOpponent) {return false;}// Simplified rule: Any piece can move one step horizontally, vertically, or diagonally// This is NOT FIDE compliant, but a placeholder for UI interactionconst rowDiff = Math.abs(startRow - endRow);const colDiff = Math.abs(startCol - endCol);if (rowDiff <= 1 && colDiff <= 1 && (rowDiff > 0 || colDiff > 0)) {return true;}return false;}function makeMove(startRow, startCol, endRow, endCol) {const movingPiece = currentBoard[startRow][startCol];const capturedPiece = currentBoard[endRow][endCol];const moveNotation = `${movingPiece}${String.fromCharCode(97 + startCol)}${8 - startRow}-${String.fromCharCode(97 + endCol)}${8 - endRow}`;currentBoard[endRow][endCol] = movingPiece;currentBoard[startRow][startCol] = '';// Clear history beyond current pointif (historyIndex < moveHistory.length - 1) {moveHistory = moveHistory.slice(0, historyIndex + 1);}moveHistory.push({ board: JSON.parse(JSON.stringify(currentBoard)), turn: currentPlayer, log: moveNotation });historyIndex = moveHistory.length - 1;updateGameLog(`${moveNotation} ${capturedPiece ? '(captures ' + capturedPiece + ')' : ''}`);currentPlayer = currentPlayer === 'w' ? 'b' : 'w';renderBoard();updateControls();if (currentPlayer === 'b') {setTimeout(makeAIMove, aiDelay);}}function makeAIMove() {const aiPieces = [];for (let r = 0; r < BOARD_SIZE; r++) {for (let c = 0; c < BOARD_SIZE; c++) {const piece = currentBoard[r][c];if (piece && piece === piece.toLowerCase()) { // It's a black pieceaiPieces.push({ row: r, col: c, piece });}}}if (aiPieces.length === 0) {updateGameLog('AI has no pieces left. White wins!');return;}let validAIMove = null;let attempts = 0;const maxAttempts = 100;while (!validAIMove && attempts < maxAttempts) {const randomPieceIndex = Math.floor(Math.random() * aiPieces.length);const { row: startRow, col: startCol } = aiPieces[randomPieceIndex];const possibleMoves = [];for (let endRow = 0; endRow < BOARD_SIZE; endRow++) {for (let endCol = 0; endCol < BOARD_SIZE; endCol++) {if (isValidMove(startRow, startCol, endRow, endCol)) {possibleMoves.push({ endRow, endCol });}}}if (possibleMoves.length > 0) {const randomMoveIndex = Math.floor(Math.random() * possibleMoves.length);const { endRow, endCol } = possibleMoves[randomMoveIndex];validAIMove = { startRow, startCol, endRow, endCol };}attempts++;}if (validAIMove) {makeMove(validAIMove.startRow, validAIMove.startCol, validAIMove.endRow, validAIMove.endCol);} else {updateGameLog('AI could not find a valid move. Standoff or White wins!');}}function newGame() {initializeBoard();}function undoMove() {if (historyIndex > 0) {historyIndex--;const prevState = moveHistory[historyIndex];currentBoard = JSON.parse(JSON.stringify(prevState.board));currentPlayer = prevState.turn;renderBoard();updateControls();updateGameLog('Undo move.');}}function redoMove() {if (historyIndex < moveHistory.length - 1) {historyIndex++;const nextState = moveHistory[historyIndex];currentBoard = JSON.parse(JSON.stringify(nextState.board));currentPlayer = nextState.turn;renderBoard();updateControls();updateGameLog('Redo move.');}}function updateControls() {undoBtn.disabled = historyIndex === 0;redoBtn.disabled = historyIndex === moveHistory.length - 1;}function updateGameLog(message) {const moveNumber = Math.ceil(moveHistory.length / 2);const logEntry = document.createElement('div');logEntry.innerHTML = `<span>${moveNumber}.</span><span>${message}</span>`;gameLogElement.appendChild(logEntry);gameLogElement.scrollTop = gameLogElement.scrollHeight;}function updateGameLogDisplay() {gameLogElement.innerHTML = '';moveHistory.forEach((state, index) => {if (state.log) {const moveNumber = Math.ceil((index + 1) / 2);const logEntry = document.createElement('div');logEntry.innerHTML = `<span>${moveNumber}.</span><span>${state.log}</span>`;gameLogElement.appendChild(logEntry);}});gameLogElement.scrollTop = gameLogElement.scrollHeight;}// Event ListenersnewGameBtn.addEventListener('click', newGame);undoBtn.addEventListener('click', undoMove);redoBtn.addEventListener('click', redoMove);difficultySelect.addEventListener('change', (event) => {aiDelay = parseInt(event.target.value, 10);updateGameLog(`AI difficulty set to ${event.target.options[event.target.selectedIndex].text}.`);});// Initial game setupinitializeBoard();